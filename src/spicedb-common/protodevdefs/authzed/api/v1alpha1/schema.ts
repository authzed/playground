// @generated by protobuf-ts 2.9.1 with parameter long_type_string,generate_dependencies
// @generated from protobuf file "authzed/api/v1alpha1/schema.proto" (package "authzed.api.v1alpha1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ReadSchemaRequest is the required data to read Object Definitions from
 * a Schema.
 *
 * @generated from protobuf message authzed.api.v1alpha1.ReadSchemaRequest
 */
export interface ReadSchemaRequest {
    /**
     * The list of names of the Object Definitions that are being requested.
     *
     * These names must be fully qualified with their namespace (e.g.
     * myblog/post).
     *
     * @generated from protobuf field: repeated string object_definitions_names = 1;
     */
    objectDefinitionsNames: string[];
}
/**
 * ReadSchemaResponse is the resulting data after having read the Object
 * Definitions from a Schema.
 *
 * @generated from protobuf message authzed.api.v1alpha1.ReadSchemaResponse
 */
export interface ReadSchemaResponse {
    /**
     * The Object Definitions that were requested.
     *
     * @generated from protobuf field: repeated string object_definitions = 1;
     */
    objectDefinitions: string[];
    /**
     * The computed revision of the returned object definitions.
     *
     * @generated from protobuf field: string computed_definitions_revision = 2;
     */
    computedDefinitionsRevision: string;
}
/**
 * WriteSchemaRequest is the required data used to "upsert" the Schema of a
 * Permissions System.
 *
 * @generated from protobuf message authzed.api.v1alpha1.WriteSchemaRequest
 */
export interface WriteSchemaRequest {
    /**
     * The Schema containing one or more Object Definitions that will be written
     * to the Permissions System.
     *
     * @generated from protobuf field: string schema = 1;
     */
    schema: string; // 256KiB
    /**
     * If specified, the existing revision of object definitions in the schema that must be present for
     * the write to succeed. If the revision specified differs (i.e. the underlying schema has changed),
     * the write call will fail with a FAILED_PRECONDITION error.
     *
     * @generated from protobuf field: string optional_definitions_revision_precondition = 2;
     */
    optionalDefinitionsRevisionPrecondition: string;
}
/**
 * WriteSchemaResponse is the resulting data after having written a Schema to
 * a Permissions System.
 *
 * @generated from protobuf message authzed.api.v1alpha1.WriteSchemaResponse
 */
export interface WriteSchemaResponse {
    /**
     * The names of the Object Definitions that were written.
     *
     * @generated from protobuf field: repeated string object_definitions_names = 1;
     */
    objectDefinitionsNames: string[];
    /**
     * The computed revision of the written object definitions.
     *
     * @generated from protobuf field: string computed_definitions_revision = 2;
     */
    computedDefinitionsRevision: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ReadSchemaRequest$Type extends MessageType<ReadSchemaRequest> {
    constructor() {
        super("authzed.api.v1alpha1.ReadSchemaRequest", [
            { no: 1, name: "object_definitions_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9]/)*[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } } } }
        ]);
    }
    create(value?: PartialMessage<ReadSchemaRequest>): ReadSchemaRequest {
        const message = { objectDefinitionsNames: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadSchemaRequest): ReadSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string object_definitions_names */ 1:
                    message.objectDefinitionsNames.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string object_definitions_names = 1; */
        for (let i = 0; i < message.objectDefinitionsNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.objectDefinitionsNames[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1alpha1.ReadSchemaRequest
 */
export const ReadSchemaRequest = new ReadSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadSchemaResponse$Type extends MessageType<ReadSchemaResponse> {
    constructor() {
        super("authzed.api.v1alpha1.ReadSchemaResponse", [
            { no: 1, name: "object_definitions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "computed_definitions_revision", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadSchemaResponse>): ReadSchemaResponse {
        const message = { objectDefinitions: [], computedDefinitionsRevision: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadSchemaResponse): ReadSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string object_definitions */ 1:
                    message.objectDefinitions.push(reader.string());
                    break;
                case /* string computed_definitions_revision */ 2:
                    message.computedDefinitionsRevision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string object_definitions = 1; */
        for (let i = 0; i < message.objectDefinitions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.objectDefinitions[i]);
        /* string computed_definitions_revision = 2; */
        if (message.computedDefinitionsRevision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.computedDefinitionsRevision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1alpha1.ReadSchemaResponse
 */
export const ReadSchemaResponse = new ReadSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteSchemaRequest$Type extends MessageType<WriteSchemaRequest> {
    constructor() {
        super("authzed.api.v1alpha1.WriteSchemaRequest", [
            { no: 1, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "262144" } } } },
            { no: 2, name: "optional_definitions_revision_precondition", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WriteSchemaRequest>): WriteSchemaRequest {
        const message = { schema: "", optionalDefinitionsRevisionPrecondition: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteSchemaRequest): WriteSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema */ 1:
                    message.schema = reader.string();
                    break;
                case /* string optional_definitions_revision_precondition */ 2:
                    message.optionalDefinitionsRevisionPrecondition = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema = 1; */
        if (message.schema !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schema);
        /* string optional_definitions_revision_precondition = 2; */
        if (message.optionalDefinitionsRevisionPrecondition !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalDefinitionsRevisionPrecondition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1alpha1.WriteSchemaRequest
 */
export const WriteSchemaRequest = new WriteSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteSchemaResponse$Type extends MessageType<WriteSchemaResponse> {
    constructor() {
        super("authzed.api.v1alpha1.WriteSchemaResponse", [
            { no: 1, name: "object_definitions_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "computed_definitions_revision", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WriteSchemaResponse>): WriteSchemaResponse {
        const message = { objectDefinitionsNames: [], computedDefinitionsRevision: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteSchemaResponse): WriteSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string object_definitions_names */ 1:
                    message.objectDefinitionsNames.push(reader.string());
                    break;
                case /* string computed_definitions_revision */ 2:
                    message.computedDefinitionsRevision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string object_definitions_names = 1; */
        for (let i = 0; i < message.objectDefinitionsNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.objectDefinitionsNames[i]);
        /* string computed_definitions_revision = 2; */
        if (message.computedDefinitionsRevision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.computedDefinitionsRevision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1alpha1.WriteSchemaResponse
 */
export const WriteSchemaResponse = new WriteSchemaResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1alpha1.SchemaService
 */
export const SchemaService = new ServiceType("authzed.api.v1alpha1.SchemaService", [
    { name: "ReadSchema", options: {}, I: ReadSchemaRequest, O: ReadSchemaResponse },
    { name: "WriteSchema", options: {}, I: WriteSchemaRequest, O: WriteSchemaResponse }
]);
